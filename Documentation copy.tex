\documentclass{article}
\usepackage[a4paper, total={6in, 8in}]{geometry}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{verbatim}
\usepackage{url}
\usepackage[hidelinks]{hyperref} % Added hyperref package
\usepackage{booktabs} % For improved table formatting, if needed

\lstset{
  basicstyle=\ttfamily\footnotesize,
  keywordstyle=\color{blue}\bfseries,
  commentstyle=\color{green!50!black},
  stringstyle=\color{red},
  numbers=left,
  numberstyle=\tiny\color{gray},
  stepnumber=1,
  numbersep=5pt,
  tabsize=2,
  breaklines=true,
  breakatwhitespace=false,
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  frame=single,
  rulecolor=\color{black},
  captionpos=b,
  language=C++,
  morekeywords={},
}

\begin{document}

\title{Tetris Project Documentation}
\author{}
\date{}
\maketitle

\tableofcontents % Added table of contents
\newpage

\section{Introduction}

This documentation provides an in-depth overview of the Tetris project, detailing its structure, specifications, and how various Object-Oriented Programming (OOP) concepts are incorporated. These concepts include encapsulation, abstraction, inheritance, polymorphism, operator overloading, and future plans for templates and virtual functions.

The Tetris project is developed in C++ using the Raylib graphics library. It simulates the classic Tetris gameplay, where differently shaped blocks descend into a grid, and the player manipulates them to form complete rows.

\section{Project Structure}

The project is organized with the following directory structure:

\begin{verbatim}
.vscode/
    c_cpp_properties.json
    launch.json
    settings.json
    tasks.json
build/
    Debug/
Documentation.tex
Font/
    Handjet.ttf
game.exe
lib/
    libgcc_s_dw2-1.dll
    libstdc++-6.dll
    raylib.h
main.code-workspace
Makefile
Sounds/
src/
    block.cpp
    block.h
    blocks.cpp
    colors.cpp
    colors.h
    game.cpp
    game.h
    grid.cpp
    grid.h
    main.cpp
    position.cpp
    position.h
\end{verbatim}

\section{Classes and Files}

\subsection{\texttt{Position} Class (\texttt{src/position.h}, \texttt{src/position.cpp})}

The \texttt{Position} class represents the position of a block within the grid.

\begin{lstlisting}[language=C++]
// src/position.h

#pragma once

class Position {
public:
    int row;
    int column;

    Position(int r = 0, int c = 0);

    Position operator+(const Position& other) const;
    bool operator==(const Position& other) const;
};
\end{lstlisting}

\subsection{\texttt{Block} Class (\texttt{src/block.h}, \texttt{src/block.cpp})}

\textbf{Encapsulation}: The \texttt{Block} class encapsulates the properties and behaviors of a Tetris block, managing its state internally and providing public methods for interaction.

\begin{lstlisting}[language=C++]
// src/block.h

#pragma once
#include <vector>
#include <map>
#include "position.h"
#include "colors.h"
#include "raylib.h"

class Block {
public:
    Block();
    void Draw(int offsetX, int offsetY);
    void Move(int rows, int columns);
    void Move(const Position& pos); // Function overloading
    void Rotate();
    void UndoRotation();
    std::vector<Position> GetCellPositions();

protected:
    int id;
    int rotationState;
    int rowOffset;
    int columnOffset;
    std::map<int, std::vector<Position>> cells;
    int cellSize;
    std::vector<Color> colors;
};
\end{lstlisting}

\subsection{Derived Block Classes (\texttt{src/blocks.cpp})}

\textbf{Inheritance}: Multiple classes (\texttt{IBlock}, \texttt{JBlock}, \texttt{LBlock}, \texttt{OBlock}, \texttt{SBlock}, \texttt{TBlock}, \texttt{ZBlock}) inherit from the \texttt{Block} class. Each derived class initializes its specific shape by setting up the \texttt{cells} member variable inherited from the \texttt{Block} class.

\textbf{Example}:

\begin{lstlisting}[language=C++]
// src/blocks.cpp

#include "block.h"

// LBlock class inheriting from Block
class LBlock : public Block {
public:
    LBlock() {
        id = 1;
        cells[0] = {Position(0, 2), Position(1, 0), Position(1, 1), Position(1, 2)};
        cells[1] = {Position(0, 1), Position(1, 1), Position(2, 1), Position(2, 2)};
        cells[2] = {Position(1, 0), Position(1, 1), Position(1, 2), Position(2, 0)};
        cells[3] = {Position(0, 0), Position(0, 1), Position(1, 1), Position(2, 1)};
        Move(0, 3);
    }
};

// Other block classes (JBlock, IBlock, OBlock, SBlock, TBlock, ZBlock) defined similarly
\end{lstlisting}

\subsection{\texttt{Grid} Class (\texttt{src/grid.h}, \texttt{src/grid.cpp})}

The \texttt{Grid} class represents the game grid where the blocks are placed. It manages the grid state, drawing, and clearing full rows.

\begin{lstlisting}[language=C++]
// src/grid.h

#pragma once
#include <vector>
#include "colors.h"
#include "raylib.h"

class Grid {
public:
    Grid();
    void Initialize();
    void Draw();
    void PlaceBlock(const std::vector<Position>& positions, int id);
    bool IsCellEmpty(int row, int column) const;
    bool IsCellInside(int row, int column) const;
    bool IsCellOutside(int row, int column) const;
    int ClearFullRows();

private:
    int numRows;
    int numCols;
    int cellSize;
    std::vector<std::vector<int>> grid;
    std::vector<Color> colors;

    bool IsRowFull(int row) const;
    void ClearRow(int row);
    void MoveRowDown(int row);
};
\end{lstlisting}

\subsection{\texttt{Game} Class (\texttt{src/game.h}, \texttt{src/game.cpp})}

\textbf{Abstraction}: The \texttt{Game} class controls the overall game logic, providing simplified methods to handle game mechanics like input handling and block movement, abstracting away the implementation details.

\begin{lstlisting}[language=C++]
// src/game.h

#pragma once
#include "grid.h"
#include "block.h"
#include "raylib.h"

class Game {
public:
    Game();
    ~Game();
    void Draw();
    void HandleInput();
    void MoveBlockDown();
    bool gameOver;
    int score;
    Music music;

private:
    void MoveBlockLeft();
    void MoveBlockRight();
    void RotateBlock();
    void LockBlock();
    bool IsBlockOutside();
    bool BlockFits();
    void Reset();
    void UpdateScore(int linesCleared, int moveDownPoints);
    Grid grid;
    Block currentBlock;
    Block nextBlock;
    std::vector<Block> blocks;
    Sound rotateSound;
    Sound clearSound;
};
\end{lstlisting}

\subsection{\texttt{Main} Function (\texttt{src/main.cpp})}

The entry point of the application, containing the game loop and user interface rendering.

\begin{lstlisting}[language=C++]
// src/main.cpp

#include <raylib.h>
#include "game.h"
#include "colors.h"

double lastUpdateTime = 0;

bool EventTriggered(double interval) {
    double currentTime = GetTime();
    if (currentTime - lastUpdateTime >= interval) {
        lastUpdateTime = currentTime;
        return true;
    }
    return false;
}

int main() {
    InitWindow(500, 620, "Tetris");
    SetTargetFPS(60);

    Font font = LoadFontEx("Font/Handjet.ttf", 64, 0, 0);

    Game game;

    while (!WindowShouldClose()) {
        UpdateMusicStream(game.music);
        game.HandleInput();
        if (EventTriggered(0.2)) { // Game speed is 0.2 seconds
            game.MoveBlockDown();
        }

        BeginDrawing();
        ClearBackground(BLACK);
        game.Draw();
        DrawTextEx(font, TextFormat("Score: %d", game.score), Vector2{310, 200}, 30, 2, WHITE);
        if (game.gameOver) {
            DrawTextEx(font, "Game Over", Vector2{200, 300}, 50, 2, WHITE);
        }
        EndDrawing();
    }

    CloseWindow();
    return 0;
}
\end{lstlisting}

\section{OOP Concepts Incorporated}

\subsection{Encapsulation}

Classes manage their own data and expose functionality through public methods. Access specifiers \texttt{public}, \texttt{protected}, and \texttt{private} are used to enforce access control, separating the interface from the implementation.

\textbf{Example}:

In the \texttt{Block} class, data members are declared as \texttt{protected}, while member functions that form the interface are declared as \texttt{public}.

\subsection{Abstraction}

Abstraction is achieved by defining clear class interfaces in header files (\texttt{.h}) and hiding the implementation details in source files (\texttt{.cpp}). This allows users of the classes to interact with them without needing to understand the internal workings.

\textbf{Example}:

The \texttt{Game} class provides methods like \texttt{HandleInput()} and \texttt{MoveBlockDown()}, abstracting the complex logic of game mechanics.

\subsection{Inheritance}

Inheritance is used to create specialized block types from the base \texttt{Block} class, allowing for code reuse and establishing a hierarchical class structure.

\textbf{Class Hierarchy}:

\begin{itemize}
    \item \texttt{Block} (base class)
    \begin{itemize}
        \item \texttt{IBlock}
        \item \texttt{JBlock}
        \item \texttt{LBlock}
        \item \texttt{OBlock}
        \item \texttt{SBlock}
        \item \texttt{TBlock}
        \item \texttt{ZBlock}
    \end{itemize}
\end{itemize}

\subsection{Polymorphism}

Polymorphism allows objects to be treated as instances of their base class rather than their actual derived class.

\subsubsection{Compile-Time Polymorphism}

\textbf{Function Overloading}:

Function overloading is used in the \texttt{Block} class to provide different ways to move a block.

\begin{lstlisting}[language=C++]
// src/block.h

class Block {
public:
    void Move(int rows, int columns);
    void Move(const Position& pos); // Overloaded function
};
\end{lstlisting}

\textbf{Operator Overloading}:

Operator overloading is implemented in the \texttt{Position} class to simplify position arithmetic.

\begin{lstlisting}[language=C++]
// src/position.cpp

Position Position::operator+(const Position &other) const {
    return Position(row + other.row, column + other.column);
}

bool Position::operator==(const Position &other) const {
    return (row == other.row) && (column == other.column);
}
\end{lstlisting}

\subsubsection{Run-Time Polymorphism}

\textbf{Virtual Functions}:

Virtual functions are planned for future implementation when adding a \texttt{Player} class to support different player types (e.g., human player, AI player).

\section{Example Code Snippets}

\subsection{Drawing a Block}

\begin{lstlisting}[language=C++]
// src/block.cpp

void Block::Draw(int offsetX, int offsetY) {
    std::vector<Position> tiles = GetCellPositions();
    for (const Position& item : tiles) {
        DrawRectangle(
            item.column * cellSize + offsetX,
            item.row * cellSize + offsetY,
            cellSize - 1, cellSize - 1,
            colors[id]
        );
    }
}
\end{lstlisting}

Demonstrates encapsulation by handling drawing internally within the \texttt{Block} class.

\subsection{Handling Block Rotation}

\begin{lstlisting}[language=C++]
// src/block.cpp

void Block::Rotate() {
    rotationState = (rotationState + 1) % cells.size();
}
\end{lstlisting}

Shows how the block manages its rotation state.

\subsection{Moving Blocks Down Automatically}

\begin{lstlisting}[language=C++]
// src/main.cpp

if (EventTriggered(0.2)) { // Game speed is 0.2 seconds
    game.MoveBlockDown();
}
\end{lstlisting}

Demonstrates how the game logic moves the current block down at regular intervals.

\section{Building the Project}

To run this project, you need to have the Raylib library installed. Raylib is a simple and easy-to-use library for enjoying videogames programming.

\subsection{Requirements}

- **Raylib Library**: Download and install Raylib from \href{https://www.raylib.com/}{www.raylib.com}. Ensure it is properly configured on your system.

\subsection{Building and Running with Visual Studio Code}

If you are using Visual Studio Code, you can utilize the provided workspace file \texttt{main.code-workspace} for an easier setup.

To build and run the project in VSCode:

\begin{enumerate}
    \item Open the \texttt{main.code-workspace} file in VSCode.
    \item Press \texttt{F5} to build and run the project using the provided tasks and launch configurations.
\end{enumerate}

\subsection{Running the Precompiled Version}

Alternatively, if you prefer a precompiled version, you can use the \texttt{game.exe} file provided in the project directory. Simply double-click the \texttt{game.exe} file to start the game.

\subsection{Building from the Command Line}

You can also build the project using the provided \texttt{Makefile}. Open a terminal in the project directory and run:

\begin{verbatim}
make
\end{verbatim}

This command will compile the source files and link the necessary libraries to produce the final executable.

\section{Future Plans}

Looking ahead, several enhancements are planned to expand the functionality and educational value of this Tetris project:

\subsection{Local Multiplayer and Additional Game Modes}

- **Local Multiplayer**: Implementing a local multiplayer mode where two players can play simultaneously on the same machine, introducing new dynamics and increasing the fun factor.

- **Additional Game Modes**:
  - **Versus Mode**: Players compete against each other, with mechanics such as sending garbage lines to the opponent when clearing multiple lines.
  - **Cooperative Mode**: Players work together to clear lines and achieve high scores.
  - **Challenge Mode**: Players face progressively increasing difficulty levels with unique challenges.
  - **Time Attack Mode**: Players aim to score as high as possible within a limited time frame.

\subsection{Online Multiplayer}

- **Networking Implementation**: Expanding the game to support online multiplayer functionality, involving networking concepts like sockets and client-server architecture.

- **Matchmaking and Lobbies**: Creating systems for players to find and join games, enhancing the social aspect of the game.

\subsection{Enhanced Graphics and User Interface}

- **Improved Visuals**: Incorporating more advanced graphics, animations, and effects to enhance visual appeal.

- **Customizable Themes**: Allowing players to customize the game's appearance with different themes and color schemes.

\subsection{Artificial Intelligence Opponents}

- **AI Players**: Introducing AI-controlled opponents with varying difficulty levels, providing a challenging single-player experience.

\subsection{Educational Opportunities}

- **Learning Advanced Concepts**: Implementing these features provides opportunities to learn about advanced programming topics such as networking, data synchronization, latency handling, and AI.

\section{Conclusion}

This Tetris project serves as a practical example of implementing OOP concepts in C++. Through encapsulation, abstraction, inheritance, polymorphism, and operator overloading, the project provides a comprehensive introduction to object-oriented programming in a game development context.

The project demonstrates how to structure a C++ application using classes and inheritance, manage game state and logic, and integrate a graphics library (Raylib) for rendering and input.

With the planned future enhancements, the project offers ample opportunities to delve into advanced topics such as networking, artificial intelligence, and enhanced user interfaces, further enriching the learning experience.

\newpage

\begin{thebibliography}{9}

\bibitem{raylib}
Raylib Official Website. \url{https://www.raylib.com/}

\bibitem{raylib_github}
Raylib GitHub Repository. \url{https://github.com/raysan5/raylib}

\bibitem{cpp_doc}
C++ Reference Documentation. \url{https://en.cppreference.com/}

\bibitem{raylib_tutorials}
Raylib Learning Resources. \url{https://www.raylib.com/learn.html}

\bibitem{tetris}
Tetris Game. \url{https://en.wikipedia.org/wiki/Tetris}

\end{thebibliography}

\end{document}